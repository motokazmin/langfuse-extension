# –ü–ª–∞–Ω –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: 2 –¥–Ω—è / $20 –±—é–¥–∂–µ—Ç

**–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:** 2026-01-24  
**–ë—é–¥–∂–µ—Ç:** $20 (—Ç–æ–∫–µ–Ω—ã AI)  
**–¶–µ–ª—å:** –ò—Å–ø—Ä–∞–≤–∏—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏ + –±–∞–∑–æ–≤—ã–µ —Ç–µ—Å—Ç—ã + –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è Clean Architecture

---

## üéØ Scope —Ä–∞–±–æ—Ç

### ‚úÖ –í–∫–ª—é—á–µ–Ω–æ:
1. –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏ (—É—Ç–µ—á–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤, –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫)
2. –ë–∞–∑–æ–≤—ã–µ unit —Ç–µ—Å—Ç—ã (50% coverage –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π)
3. –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è Clean Architecture (handler/service/repository —Å–ª–æ–∏)
4. Godoc/JSDoc –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π

### ‚ùå –ò—Å–∫–ª—é—á–µ–Ω–æ:
- –°–ª–æ–∂–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ (>1 –¥–Ω—è)
- CI/CD –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
- Monitoring/metrics
- E2E —Ç–µ—Å—Ç—ã
- –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

---

## üìä –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

| –ú–µ—Ç—Ä–∏–∫–∞ | –¢–µ–∫—É—â–µ–µ | –¶–µ–ª—å | –ö—Ä–∏—Ç–µ—Ä–∏–π |
|---------|---------|------|----------|
| –¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ | 0% | 50% | ‚úÖ –ö—Ä–∏—Ç–∏—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ |
| –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏ | 4 | 0 | ‚úÖ –í—Å–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã |
| –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ | –ú–æ–Ω–æ–ª–∏—Ç | –°–ª–æ–∏ | ‚úÖ handler/service/repository |
| Godoc –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ | 0% | 60% | ‚úÖ –ö–ª—é—á–µ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ |
| –£—Ç–µ—á–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤ | 1 | 0 | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ |

---

## üìÖ –î–µ–Ω—å 1: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏ + –ë–∞–∑–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (8 —á–∞—Å–æ–≤)

### üåÖ –£—Ç—Ä–æ (09:00 - 13:00) ‚Äî 4 —á–∞—Å–∞

#### ‚è∞ 09:00 - 09:30 | –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ (30 –º–∏–Ω)
**–ó–∞–¥–∞—á–∏:**
- [ ] –°–æ–∑–¥–∞—Ç—å –≤–µ—Ç–∫—É `feat/2-day-optimization`
- [ ] –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –¥–ª—è —Ç–µ—Å—Ç–æ–≤: `go get github.com/stretchr/testify`
- [ ] –°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞–ø–æ–∫ –¥–ª—è –Ω–æ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

**–ö–æ–º–∞–Ω–¥—ã:**
```bash
cd ai-back
git checkout -b feat/2-day-optimization
go get github.com/stretchr/testify/assert
go get github.com/stretchr/testify/mock

mkdir -p internal/{handler,service,repository,domain,config}
mkdir -p internal/handler/handler_test
mkdir -p internal/service/service_test
mkdir -p internal/repository/repository_test
```

**Checkpoint:** `git commit -m "chore: setup project structure for clean architecture"`

---

#### ‚è∞ 09:30 - 10:30 | –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ë–ê–ì #1: –£—Ç–µ—á–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ (60 –º–∏–Ω)

**–ü—Ä–æ–±–ª–µ–º–∞:** `defer resp.Body.Close()` –≤ —Ü–∏–∫–ª–µ retry (main.go:325)

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:**
```go
// main.go, —Ñ—É–Ω–∫—Ü–∏—è getTraceFromLangfuse()
for attempt := 1; attempt <= 3; attempt++ {
    // ...
    resp, err := client.Do(req)
    if err != nil {
        lastErr = err
        continue
    }
    
    // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    func() {
        defer resp.Body.Close()
        
        if resp.StatusCode != http.StatusOK {
            bodyBytes, _ := io.ReadAll(resp.Body)
            log.Printf("‚ö†Ô∏è  –¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: %s", string(bodyBytes))
            lastErr = fmt.Errorf("Langfuse API –≤–µ—Ä–Ω—É–ª —Å—Ç–∞—Ç—É—Å: %s", resp.Status)
            return
        }
        
        var data map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
            log.Printf("‚ùå –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON: %v", err)
            lastErr = err
            return
        }
        
        log.Printf("‚úÖ –î–∞–Ω–Ω—ã–µ —Ç—Ä–µ–π—Å–∞ —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω—ã")
        result = data
    }()
    
    if result != nil {
        return result, nil
    }
}
```

**–¢–µ—Å—Ç:**
```go
// internal/repository/repository_test/langfuse_client_test.go
func TestGetTraceFromLangfuse_NoResourceLeak(t *testing.T) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ response.Body –∑–∞–∫—Ä—ã–≤–∞—é—Ç—Å—è
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º httptest.Server –¥–ª—è –º–æ–∫–∏—Ä–æ–≤–∞–Ω–∏—è
}
```

**Checkpoint:** `git commit -m "fix: resource leak in getTraceFromLangfuse retry loop"`

---

#### ‚è∞ 10:30 - 11:00 | –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ë–ê–ì #2: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ (30 –º–∏–Ω)

**–ü—Ä–æ–±–ª–µ–º–∞:** `req, _ := http.NewRequest()` (main.go:316)

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:**
```go
// main.go:316
req, err := http.NewRequest("GET", url, nil)
if err != nil {
    return nil, fmt.Errorf("failed to create HTTP request: %w", err)
}
req.SetBasicAuth(publicKey, secretKey)
```

**–¢–µ—Å—Ç:**
```go
func TestGetTraceFromLangfuse_InvalidURL(t *testing.T) {
    // –¢–µ—Å—Ç —Å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º URL
    _, err := getTraceFromLangfuse("invalid\x00url")
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "failed to create HTTP request")
}
```

**Checkpoint:** `git commit -m "fix: handle http.NewRequest error in getTraceFromLangfuse"`

---

#### ‚è∞ 11:00 - 11:15 | –ü–µ—Ä–µ—Ä—ã–≤ (15 –º–∏–Ω) ‚òï

---

#### ‚è∞ 11:15 - 12:15 | –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ë–ê–ì #3: –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è aiClient (60 –º–∏–Ω)

**–ü—Ä–æ–±–ª–µ–º–∞:** `var aiClient ai.AIClient` ‚Äî –≥–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è (main.go:26)

**–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

**–§–∞–π–ª:** `internal/handler/analyze_handler.go`
```go
package handler

import (
    "github.com/gin-gonic/gin"
    "langfuse-analyzer-backend/ai"
    "langfuse-analyzer-backend/internal/service"
)

type AnalyzeHandler struct {
    analyzeService *service.AnalyzeService
}

func NewAnalyzeHandler(analyzeService *service.AnalyzeService) *AnalyzeHandler {
    return &AnalyzeHandler{
        analyzeService: analyzeService,
    }
}

func (h *AnalyzeHandler) Handle(c *gin.Context) {
    var req AnalyzeRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "Invalid JSON: " + err.Error()})
        return
    }
    
    result, err := h.analyzeService.AnalyzeTrace(c.Request.Context(), req.TraceID)
    if err != nil {
        // ... –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
        return
    }
    
    c.JSON(200, gin.H{"data": result})
}

type AnalyzeRequest struct {
    TraceID string `json:"traceId" binding:"required"`
}
```

**–§–∞–π–ª:** `internal/service/analyze_service.go`
```go
package service

import (
    "context"
    "langfuse-analyzer-backend/ai"
    "langfuse-analyzer-backend/internal/repository"
)

type AnalyzeService struct {
    aiClient       ai.AIClient
    langfuseRepo   repository.LangfuseRepository
}

func NewAnalyzeService(aiClient ai.AIClient, langfuseRepo repository.LangfuseRepository) *AnalyzeService {
    return &AnalyzeService{
        aiClient:     aiClient,
        langfuseRepo: langfuseRepo,
    }
}

func (s *AnalyzeService) AnalyzeTrace(ctx context.Context, traceID string) (interface{}, error) {
    // 1. –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–µ–π—Å –∏–∑ Langfuse
    traceData, err := s.langfuseRepo.GetTrace(ctx, traceID)
    if err != nil {
        return nil, err
    }
    
    // 2. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ AI
    result, err := s.aiClient.AnalyzeTrace(ctx, traceData)
    if err != nil {
        return nil, err
    }
    
    return result, nil
}
```

**–§–∞–π–ª:** `internal/repository/langfuse_repository.go`
```go
package repository

import (
    "context"
)

type LangfuseRepository interface {
    GetTrace(ctx context.Context, traceID string) (map[string]interface{}, error)
}

type langfuseClient struct {
    publicKey string
    secretKey string
    baseURL   string
}

func NewLangfuseRepository(publicKey, secretKey, baseURL string) LangfuseRepository {
    return &langfuseClient{
        publicKey: publicKey,
        secretKey: secretKey,
        baseURL:   baseURL,
    }
}

func (c *langfuseClient) GetTrace(ctx context.Context, traceID string) (map[string]interface{}, error) {
    // –ü–µ—Ä–µ–Ω–æ—Å–∏–º –ª–æ–≥–∏–∫—É –∏–∑ getTraceFromLangfuse() —Å—é–¥–∞
    // + –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–≥–æ–≤
}
```

**–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ main.go:**
```go
func main() {
    // ... –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ...
    
    // –°–æ–∑–¥–∞—ë–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
    aiClient := ai.NewAIClient(provider, apiKey, baseURL, aiModel, maxTokens)
    langfuseRepo := repository.NewLangfuseRepository(
        os.Getenv("LANGFUSE_PUBLIC_KEY"),
        os.Getenv("LANGFUSE_SECRET_KEY"),
        os.Getenv("LANGFUSE_BASEURL"),
    )
    
    // –°–æ–∑–¥–∞—ë–º —Å–µ—Ä–≤–∏—Å
    analyzeService := service.NewAnalyzeService(aiClient, langfuseRepo)
    
    // –°–æ–∑–¥–∞—ë–º handler
    analyzeHandler := handler.NewAnalyzeHandler(analyzeService)
    
    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ä–æ—É—Ç—ã
    router.POST("/analyze", analyzeHandler.Handle)
    
    router.Run(":8080")
}
```

**Checkpoint:** `git commit -m "refactor: introduce handler/service/repository layers"`

---

#### ‚è∞ 12:15 - 13:00 | –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ë–ê–ì #4: –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ (45 –º–∏–Ω)

**–ü—Ä–æ–±–ª–µ–º–∞:** –ù–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤ –æ—à–∏–±–∫–∞—Ö, —Å–ª–æ–∂–Ω–æ –æ—Ç—Å–ª–µ–¥–∏—Ç—å

**–†–µ—à–µ–Ω–∏–µ:** –î–æ–±–∞–≤–∏—Ç—å –æ–±—ë—Ä—Ç–∫—É –æ—à–∏–±–æ–∫ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º

**–§–∞–π–ª:** `internal/repository/langfuse_repository.go`
```go
func (c *langfuseClient) GetTrace(ctx context.Context, traceID string) (map[string]interface{}, error) {
    url := fmt.Sprintf("%s/api/public/traces/%s", c.baseURL, traceID)
    
    // ... retry –ª–æ–≥–∏–∫–∞ ...
    
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create request for trace %s: %w", traceID, err)
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch trace %s from Langfuse: %w", traceID, err)
    }
    
    // ...
}
```

**Checkpoint:** `git commit -m "fix: add context to error messages for better debugging"`

---

### üåÜ –û–±–µ–¥ (13:00 - 14:00) ‚Äî 1 —á–∞—Å üçΩÔ∏è

---

### üåá –í–µ—á–µ—Ä (14:00 - 18:00) ‚Äî 4 —á–∞—Å–∞

#### ‚è∞ 14:00 - 15:30 | Unit —Ç–µ—Å—Ç—ã –¥–ª—è repository (90 –º–∏–Ω)

**–¶–µ–ª—å:** 50% coverage –¥–ª—è `LangfuseRepository`

**–§–∞–π–ª:** `internal/repository/repository_test/langfuse_repository_test.go`

```go
package repository_test

import (
    "context"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "langfuse-analyzer-backend/internal/repository"
)

func TestLangfuseRepository_GetTrace_Success(t *testing.T) {
    // Mock Langfuse API
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        assert.Equal(t, "/api/public/traces/test-trace-123", r.URL.Path)
        
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"id": "test-trace-123", "name": "test"}`))
    }))
    defer server.Close()
    
    repo := repository.NewLangfuseRepository("pk-test", "sk-test", server.URL)
    
    trace, err := repo.GetTrace(context.Background(), "test-trace-123")
    
    assert.NoError(t, err)
    assert.Equal(t, "test-trace-123", trace["id"])
}

func TestLangfuseRepository_GetTrace_Retry(t *testing.T) {
    attempts := 0
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        attempts++
        if attempts < 3 {
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"id": "test-trace-123"}`))
    }))
    defer server.Close()
    
    repo := repository.NewLangfuseRepository("pk-test", "sk-test", server.URL)
    
    trace, err := repo.GetTrace(context.Background(), "test-trace-123")
    
    assert.NoError(t, err)
    assert.Equal(t, 3, attempts, "Should retry 3 times")
}

func TestLangfuseRepository_GetTrace_NotFound(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusNotFound)
    }))
    defer server.Close()
    
    repo := repository.NewLangfuseRepository("pk-test", "sk-test", server.URL)
    
    _, err := repo.GetTrace(context.Background(), "nonexistent")
    
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "404")
}

func TestLangfuseRepository_GetTrace_InvalidJSON(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`invalid json`))
    }))
    defer server.Close()
    
    repo := repository.NewLangfuseRepository("pk-test", "sk-test", server.URL)
    
    _, err := repo.GetTrace(context.Background(), "test-trace")
    
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "decode")
}
```

**–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤:**
```bash
cd ai-back
go test ./internal/repository/repository_test/... -v -cover
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:** Coverage ~70% –¥–ª—è repository

**Checkpoint:** `git commit -m "test: add unit tests for LangfuseRepository (70% coverage)"`

---

#### ‚è∞ 15:30 - 17:00 | Unit —Ç–µ—Å—Ç—ã –¥–ª—è service (90 –º–∏–Ω)

**–¶–µ–ª—å:** 50% coverage –¥–ª—è `AnalyzeService`

**–§–∞–π–ª:** `internal/service/service_test/analyze_service_test.go`

```go
package service_test

import (
    "context"
    "errors"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "langfuse-analyzer-backend/internal/service"
)

// Mock –¥–ª—è AIClient
type MockAIClient struct {
    mock.Mock
}

func (m *MockAIClient) AnalyzeTrace(ctx context.Context, traceData map[string]interface{}) (string, error) {
    args := m.Called(ctx, traceData)
    return args.String(0), args.Error(1)
}

// Mock –¥–ª—è LangfuseRepository
type MockLangfuseRepository struct {
    mock.Mock
}

func (m *MockLangfuseRepository) GetTrace(ctx context.Context, traceID string) (map[string]interface{}, error) {
    args := m.Called(ctx, traceID)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(map[string]interface{}), args.Error(1)
}

func TestAnalyzeService_AnalyzeTrace_Success(t *testing.T) {
    mockAI := new(MockAIClient)
    mockRepo := new(MockLangfuseRepository)
    
    traceData := map[string]interface{}{"id": "test-123"}
    mockRepo.On("GetTrace", mock.Anything, "test-123").Return(traceData, nil)
    mockAI.On("AnalyzeTrace", mock.Anything, traceData).Return(`{"status": "ok"}`, nil)
    
    service := service.NewAnalyzeService(mockAI, mockRepo)
    
    result, err := service.AnalyzeTrace(context.Background(), "test-123")
    
    assert.NoError(t, err)
    assert.NotNil(t, result)
    mockRepo.AssertExpectations(t)
    mockAI.AssertExpectations(t)
}

func TestAnalyzeService_AnalyzeTrace_LangfuseError(t *testing.T) {
    mockAI := new(MockAIClient)
    mockRepo := new(MockLangfuseRepository)
    
    mockRepo.On("GetTrace", mock.Anything, "test-123").Return(nil, errors.New("langfuse error"))
    
    service := service.NewAnalyzeService(mockAI, mockRepo)
    
    _, err := service.AnalyzeTrace(context.Background(), "test-123")
    
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "langfuse error")
    mockRepo.AssertExpectations(t)
}

func TestAnalyzeService_AnalyzeTrace_AIError(t *testing.T) {
    mockAI := new(MockAIClient)
    mockRepo := new(MockLangfuseRepository)
    
    traceData := map[string]interface{}{"id": "test-123"}
    mockRepo.On("GetTrace", mock.Anything, "test-123").Return(traceData, nil)
    mockAI.On("AnalyzeTrace", mock.Anything, traceData).Return("", errors.New("AI error"))
    
    service := service.NewAnalyzeService(mockAI, mockRepo)
    
    _, err := service.AnalyzeTrace(context.Background(), "test-123")
    
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "AI error")
    mockRepo.AssertExpectations(t)
    mockAI.AssertExpectations(t)
}
```

**–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤:**
```bash
go test ./internal/service/service_test/... -v -cover
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:** Coverage ~60% –¥–ª—è service

**Checkpoint:** `git commit -m "test: add unit tests for AnalyzeService with mocks (60% coverage)"`

---

#### ‚è∞ 17:00 - 18:00 | Godoc –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è (60 –º–∏–Ω)

**–¶–µ–ª—å:** –î–æ–±–∞–≤–∏—Ç—å Godoc –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –¥–ª—è –≤—Å–µ—Ö —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π

**–§–∞–π–ª:** `internal/repository/langfuse_repository.go`
```go
// LangfuseRepository defines the interface for interacting with Langfuse API.
// It provides methods to fetch trace data from Langfuse.
type LangfuseRepository interface {
    // GetTrace fetches trace data from Langfuse by trace ID.
    // It retries up to 3 times with exponential backoff on failure.
    //
    // Parameters:
    //   - ctx: Context for cancellation and timeout
    //   - traceID: Unique identifier of the trace
    //
    // Returns:
    //   - Trace data as a map
    //   - Error if all retry attempts fail or trace not found
    GetTrace(ctx context.Context, traceID string) (map[string]interface{}, error)
}

// NewLangfuseRepository creates a new Langfuse repository client.
//
// Parameters:
//   - publicKey: Langfuse public API key
//   - secretKey: Langfuse secret API key
//   - baseURL: Langfuse API base URL (e.g., https://cloud.langfuse.com)
//
// Returns:
//   - Configured LangfuseRepository instance
func NewLangfuseRepository(publicKey, secretKey, baseURL string) LangfuseRepository {
    // ...
}
```

**–§–∞–π–ª:** `internal/service/analyze_service.go`
```go
// AnalyzeService provides business logic for analyzing traces using AI.
// It orchestrates fetching trace data from Langfuse and analyzing it with AI.
type AnalyzeService struct {
    aiClient     ai.AIClient
    langfuseRepo repository.LangfuseRepository
}

// NewAnalyzeService creates a new AnalyzeService instance.
//
// Parameters:
//   - aiClient: AI client for trace analysis (OpenRouter or Ollama)
//   - langfuseRepo: Repository for fetching traces from Langfuse
//
// Returns:
//   - Configured AnalyzeService instance
func NewAnalyzeService(aiClient ai.AIClient, langfuseRepo repository.LangfuseRepository) *AnalyzeService {
    // ...
}

// AnalyzeTrace analyzes a trace by its ID using AI.
// It first fetches the trace from Langfuse, then sends it to AI for analysis.
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - traceID: Unique identifier of the trace to analyze
//
// Returns:
//   - Analysis result from AI
//   - Error if trace fetch or AI analysis fails
func (s *AnalyzeService) AnalyzeTrace(ctx context.Context, traceID string) (interface{}, error) {
    // ...
}
```

**–§–∞–π–ª:** `internal/handler/analyze_handler.go`
```go
// AnalyzeHandler handles HTTP requests for trace analysis.
// It validates requests, delegates to AnalyzeService, and formats responses.
type AnalyzeHandler struct {
    analyzeService *service.AnalyzeService
}

// NewAnalyzeHandler creates a new AnalyzeHandler instance.
//
// Parameters:
//   - analyzeService: Service for analyzing traces
//
// Returns:
//   - Configured AnalyzeHandler instance
func NewAnalyzeHandler(analyzeService *service.AnalyzeService) *AnalyzeHandler {
    // ...
}

// Handle processes HTTP POST /analyze requests.
// It expects JSON body with traceId field.
//
// Request body:
//   {"traceId": "string"}
//
// Response (success):
//   {"data": {...}}
//
// Response (error):
//   {"error": "string"}
func (h *AnalyzeHandler) Handle(c *gin.Context) {
    // ...
}
```

**–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏:**
```bash
go doc internal/repository.LangfuseRepository
go doc internal/service.AnalyzeService
go doc internal/handler.AnalyzeHandler
```

**Checkpoint:** `git commit -m "docs: add Godoc comments for all exported functions"`

---

### üìä –ò—Ç–æ–≥–∏ –î–Ω—è 1

**–í—ã–ø–æ–ª–Ω–µ–Ω–æ:**
- ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã 4 –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –±–∞–≥–∞
- ‚úÖ –°–æ–∑–¥–∞–Ω–∞ –±–∞–∑–æ–≤–∞—è Clean Architecture (handler/service/repository)
- ‚úÖ –ù–∞–ø–∏—Å–∞–Ω—ã unit —Ç–µ—Å—Ç—ã –¥–ª—è repository (~70% coverage)
- ‚úÖ –ù–∞–ø–∏—Å–∞–Ω—ã unit —Ç–µ—Å—Ç—ã –¥–ª—è service (~60% coverage)
- ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ Godoc –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

**–ú–µ—Ç—Ä–∏–∫–∏:**
- –¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ: 0% ‚Üí ~40% (repository + service)
- –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏: 4 ‚Üí 0
- –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: –ú–æ–Ω–æ–ª–∏—Ç ‚Üí –°–ª–æ–∏

**Git –∫–æ–º–º–∏—Ç—ã:** 6 –∫–æ–º–º–∏—Ç–æ–≤

---

## üìÖ –î–µ–Ω—å 2: –¢–µ—Å—Ç—ã –¥–ª—è handler + TypeScript + –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è (8 —á–∞—Å–æ–≤)

### üåÖ –£—Ç—Ä–æ (09:00 - 13:00) ‚Äî 4 —á–∞—Å–∞

#### ‚è∞ 09:00 - 10:30 | Unit —Ç–µ—Å—Ç—ã –¥–ª—è handler (90 –º–∏–Ω)

**–¶–µ–ª—å:** 50% coverage –¥–ª—è `AnalyzeHandler`

**–§–∞–π–ª:** `internal/handler/handler_test/analyze_handler_test.go`

```go
package handler_test

import (
    "bytes"
    "encoding/json"
    "errors"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "langfuse-analyzer-backend/internal/handler"
)

type MockAnalyzeService struct {
    mock.Mock
}

func (m *MockAnalyzeService) AnalyzeTrace(ctx context.Context, traceID string) (interface{}, error) {
    args := m.Called(ctx, traceID)
    return args.Get(0), args.Error(1)
}

func TestAnalyzeHandler_Handle_Success(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    mockService := new(MockAnalyzeService)
    mockService.On("AnalyzeTrace", mock.Anything, "test-123").Return(
        map[string]interface{}{"status": "ok"},
        nil,
    )
    
    handler := handler.NewAnalyzeHandler(mockService)
    
    router := gin.New()
    router.POST("/analyze", handler.Handle)
    
    body := `{"traceId": "test-123"}`
    req := httptest.NewRequest("POST", "/analyze", bytes.NewBufferString(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.NotNil(t, response["data"])
    
    mockService.AssertExpectations(t)
}

func TestAnalyzeHandler_Handle_InvalidJSON(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    mockService := new(MockAnalyzeService)
    handler := handler.NewAnalyzeHandler(mockService)
    
    router := gin.New()
    router.POST("/analyze", handler.Handle)
    
    body := `{invalid json}`
    req := httptest.NewRequest("POST", "/analyze", bytes.NewBufferString(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusBadRequest, w.Code)
}

func TestAnalyzeHandler_Handle_MissingTraceID(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    mockService := new(MockAnalyzeService)
    handler := handler.NewAnalyzeHandler(mockService)
    
    router := gin.New()
    router.POST("/analyze", handler.Handle)
    
    body := `{}`
    req := httptest.NewRequest("POST", "/analyze", bytes.NewBufferString(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusBadRequest, w.Code)
}

func TestAnalyzeHandler_Handle_ServiceError(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    mockService := new(MockAnalyzeService)
    mockService.On("AnalyzeTrace", mock.Anything, "test-123").Return(
        nil,
        errors.New("service error"),
    )
    
    handler := handler.NewAnalyzeHandler(mockService)
    
    router := gin.New()
    router.POST("/analyze", handler.Handle)
    
    body := `{"traceId": "test-123"}`
    req := httptest.NewRequest("POST", "/analyze", bytes.NewBufferString(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusInternalServerError, w.Code)
    
    mockService.AssertExpectations(t)
}
```

**–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤:**
```bash
go test ./... -v -cover
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:** Overall coverage ~50%

**Checkpoint:** `git commit -m "test: add unit tests for AnalyzeHandler (50% coverage achieved)"`

---

#### ‚è∞ 10:30 - 11:00 | –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ç–µ—Å—Ç (30 –º–∏–Ω)

**–¶–µ–ª—å:** –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–∞–±–æ—Ç—É –≤—Å–µ—Ö —Å–ª–æ—ë–≤ –≤–º–µ—Å—Ç–µ

**–§–∞–π–ª:** `internal/integration_test/analyze_integration_test.go`

```go
package integration_test

import (
    "bytes"
    "context"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "langfuse-analyzer-backend/internal/handler"
    "langfuse-analyzer-backend/internal/service"
)

func TestAnalyzeFlow_EndToEnd(t *testing.T) {
    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –Ω–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ AI API –∫–ª—é—á–∞
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    gin.SetMode(gin.TestMode)
    
    // Mock Langfuse API
    langfuseServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{
            "id": "test-trace-123",
            "name": "test trace",
            "observations": []
        }`))
    }))
    defer langfuseServer.Close()
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º mock AI client
    mockAI := new(MockAIClient)
    mockAI.On("AnalyzeTrace", mock.Anything, mock.Anything).Return(
        `{"analysisSummary": {"overallStatus": "HEALTHY"}}`,
        nil,
    )
    
    // –°–æ–∑–¥–∞—ë–º —Ä–µ–∞–ª—å–Ω—ã–π repository
    langfuseRepo := repository.NewLangfuseRepository("pk-test", "sk-test", langfuseServer.URL)
    
    // –°–æ–∑–¥–∞—ë–º service –∏ handler
    analyzeService := service.NewAnalyzeService(mockAI, langfuseRepo)
    analyzeHandler := handler.NewAnalyzeHandler(analyzeService)
    
    // –°–æ–∑–¥–∞—ë–º router
    router := gin.New()
    router.POST("/analyze", analyzeHandler.Handle)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
    body := `{"traceId": "test-trace-123"}`
    req := httptest.NewRequest("POST", "/analyze", bytes.NewBufferString(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    assert.Equal(t, http.StatusOK, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.NotNil(t, response["data"])
}
```

**–ó–∞–ø—É—Å–∫:**
```bash
go test ./internal/integration_test/... -v
```

**Checkpoint:** `git commit -m "test: add integration test for analyze flow"`

---

#### ‚è∞ 11:00 - 11:15 | –ü–µ—Ä–µ—Ä—ã–≤ (15 –º–∏–Ω) ‚òï

---

#### ‚è∞ 11:15 - 12:15 | TypeScript: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ `any` + —Ç–∏–ø–∏–∑–∞—Ü–∏—è (60 –º–∏–Ω)

**–ü—Ä–æ–±–ª–µ–º–∞:** `response: any` –≤ `injector.ts:123`

**–§–∞–π–ª:** `crome-ext/src/types/analysis.ts` (–Ω–æ–≤—ã–π)
```typescript
/**
 * Response from backend /analyze endpoint
 */
export interface AnalysisResponse {
  data: AnalysisData;
}

/**
 * Analysis data structure
 */
export interface AnalysisData {
  analysisSummary: AnalysisSummary;
  detailedAnalysis: DetailedAnalysis;
}

/**
 * Summary of the trace analysis
 */
export interface AnalysisSummary {
  traceId: string;
  overallStatus: 'HEALTHY' | 'WARNING' | 'ERROR';
  keyFinding: string;
}

/**
 * Detailed analysis with anomaly detection
 */
export interface DetailedAnalysis {
  anomalyType: AnomalyType;
  description: string;
  rootCause: string;
  recommendation: string;
}

/**
 * Types of anomalies that can be detected
 */
export type AnomalyType = 
  | 'NONE' 
  | 'ERROR' 
  | 'PERFORMANCE_BOTTLENECK' 
  | 'HIGH_COST' 
  | 'LOGICAL_LOOP';

/**
 * Error response from backend
 */
export interface ErrorResponse {
  error: string;
  code?: string;
  retryAfter?: number;
}
```

**–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ `injector.ts`:**
```typescript
import type { AnalysisResponse, AnalysisData } from '../types/analysis';

/**
 * Displays analysis results in a modal window
 * @param response - Analysis response from backend
 * @param traceId - Trace ID being analyzed
 */
const displayAnalysisResults = (response: AnalysisResponse, traceId: string): void => {
  // –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –µ—Å–ª–∏ –µ—Å—Ç—å
  const existingModal = document.getElementById('ai-analyzer-modal');
  if (existingModal) {
    existingModal.remove();
  }

  // –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∞–Ω–∞–ª–∏–∑–∞ —Å —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å—é
  const data: AnalysisData = response.data;
  const { analysisSummary, detailedAnalysis } = data;
  
  // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥
};
```

**–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ `background/index.ts`:**
```typescript
import type { AnalysisResponse, ErrorResponse } from '../types/analysis';

interface AnalyzeTraceMessage {
  type: "ANALYZE_TRACE";
  traceId: string;
  timestamp: string;
}

chrome.runtime.onMessage.addListener(
  (
    message: AnalyzeTraceMessage,
    sender: chrome.runtime.MessageSender,
    sendResponse: (response: AnalysisResponse | ErrorResponse) => void
  ): boolean => {
    // ... –∫–æ–¥ —Å —Ç–∏–ø–∏–∑–∞—Ü–∏–µ–π
  }
);
```

**Checkpoint:** `git commit -m "fix: replace 'any' with proper TypeScript interfaces"`

---

#### ‚è∞ 12:15 - 13:00 | JSDoc –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è TypeScript (45 –º–∏–Ω)

**–§–∞–π–ª:** `crome-ext/src/content-script/injector.ts`

```typescript
/**
 * Extracts trace ID from Langfuse URL.
 * Supports two formats:
 * - /traces/TRACE_ID
 * - /traces?peek=TRACE_ID
 * 
 * @returns Trace ID if found, null otherwise
 * 
 * @example
 * // URL: https://cloud.langfuse.com/traces?peek=abc-123
 * extractTraceId() // returns "abc-123"
 */
const extractTraceId = (): string | null => {
  // ...
};

/**
 * Shows progress indicator during analysis.
 * Creates a fixed-position overlay with spinner and status text.
 * 
 * @returns Object with update and remove methods
 * 
 * @example
 * const progress = showProgressIndicator();
 * progress.update('Fetching data...');
 * progress.remove();
 */
const showProgressIndicator = (): { 
  update: (step: string) => void; 
  remove: () => void 
} => {
  // ...
};

/**
 * Sends analyze request to background script.
 * Shows progress indicator and handles response/errors.
 * 
 * @param traceId - Trace ID to analyze
 * @throws {Error} If Chrome runtime error occurs
 * 
 * @example
 * await sendAnalyzeRequest('trace-123');
 */
const sendAnalyzeRequest = async (traceId: string): Promise<void> => {
  // ...
};

/**
 * Handles analyze button click event.
 * Retrieves stored trace ID and initiates analysis.
 * 
 * @example
 * button.onclick = handleAnalyzeClick;
 */
const handleAnalyzeClick = async (): Promise<void> => {
  // ...
};

/**
 * Injects AI-Analyze button into Langfuse UI.
 * Only injects if on trace page with valid trace ID.
 * 
 * @example
 * tryInjectApp(); // Called on URL change
 */
const tryInjectApp = (): void => {
  // ...
};
```

**Checkpoint:** `git commit -m "docs: add JSDoc comments for all TypeScript functions"`

---

### üåÜ –û–±–µ–¥ (13:00 - 14:00) ‚Äî 1 —á–∞—Å üçΩÔ∏è

---

### üåá –í–µ—á–µ—Ä (14:00 - 18:00) ‚Äî 4 —á–∞—Å–∞

#### ‚è∞ 14:00 - 15:00 | –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ main.go (60 –º–∏–Ω)

**–¶–µ–ª—å:** –£–ø—Ä–æ—Å—Ç–∏—Ç—å main.go, –≤—ã–Ω–µ—Å—Ç–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é

**–§–∞–π–ª:** `internal/config/config.go` (–Ω–æ–≤—ã–π)
```go
package config

import (
    "fmt"
    "os"
    "strconv"
    
    "github.com/joho/godotenv"
)

// Config holds application configuration
type Config struct {
    // Server
    Port string
    
    // Langfuse
    LangfusePublicKey string
    LangfuseSecretKey string
    LangfuseBaseURL   string
    
    // AI Provider
    AIProvider         string
    AIAPIKey          string
    AIBaseURL         string
    AIModel           string
    AIMaxTokens       int
    
    // Chrome Extension
    ChromeExtensionID string
}

// LoadConfig loads configuration from environment variables
func LoadConfig() (*Config, error) {
    // Load .env file
    if err := godotenv.Load(); err != nil {
        // Not critical, env vars might be set directly
    }
    
    cfg := &Config{
        Port:               getEnvOrDefault("PORT", "8080"),
        LangfusePublicKey:  os.Getenv("LANGFUSE_PUBLIC_KEY"),
        LangfuseSecretKey:  os.Getenv("LANGFUSE_SECRET_KEY"),
        LangfuseBaseURL:    getEnvOrDefault("LANGFUSE_BASEURL", "https://cloud.langfuse.com"),
        AIProvider:         getEnvOrDefault("AI_PROVIDER", "openrouter"),
        AIAPIKey:          os.Getenv("AI_API_KEY"),
        AIBaseURL:         getEnvOrDefault("AI_BASE_URL", "https://openrouter.ai/api/v1"),
        AIModel:           getEnvOrDefault("AI_MODEL", "google/gemini-2.0-flash-exp:free"),
        AIMaxTokens:       getEnvAsInt("AI_MAX_TOKENS", 1000),
        ChromeExtensionID: os.Getenv("CHROME_EXTENSION_ID"),
    }
    
    // Validate required fields
    if cfg.LangfusePublicKey == "" {
        return nil, fmt.Errorf("LANGFUSE_PUBLIC_KEY is required")
    }
    if cfg.LangfuseSecretKey == "" {
        return nil, fmt.Errorf("LANGFUSE_SECRET_KEY is required")
    }
    if cfg.ChromeExtensionID == "" {
        return nil, fmt.Errorf("CHROME_EXTENSION_ID is required")
    }
    
    return cfg, nil
}

func getEnvOrDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

**–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ main.go:**
```go
package main

import (
    "log"
    
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    
    "langfuse-analyzer-backend/ai"
    "langfuse-analyzer-backend/internal/config"
    "langfuse-analyzer-backend/internal/handler"
    "langfuse-analyzer-backend/internal/repository"
    "langfuse-analyzer-backend/internal/service"
)

func main() {
    // Load configuration
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }
    
    log.Printf("ü§ñ AI Provider: %s", cfg.AIProvider)
    log.Printf("üß† AI Model: %s", cfg.AIModel)
    
    // Create dependencies
    var provider ai.ProviderType
    if cfg.AIProvider == "ollama" {
        provider = ai.ProviderOllama
    } else {
        provider = ai.ProviderOpenRouter
    }
    
    aiClient := ai.NewAIClient(provider, cfg.AIAPIKey, cfg.AIBaseURL, cfg.AIModel, cfg.AIMaxTokens)
    langfuseRepo := repository.NewLangfuseRepository(cfg.LangfusePublicKey, cfg.LangfuseSecretKey, cfg.LangfuseBaseURL)
    
    // Create service and handler
    analyzeService := service.NewAnalyzeService(aiClient, langfuseRepo)
    analyzeHandler := handler.NewAnalyzeHandler(analyzeService)
    
    // Setup router
    router := setupRouter(cfg, analyzeHandler)
    
    // Start server
    log.Printf("üöÄ Server starting on :%s", cfg.Port)
    if err := router.Run(":" + cfg.Port); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}

func setupRouter(cfg *config.Config, analyzeHandler *handler.AnalyzeHandler) *gin.Engine {
    router := gin.Default()
    
    // CORS configuration
    chromeExtensionOrigin := "chrome-extension://" + cfg.ChromeExtensionID
    corsConfig := cors.Config{
        AllowOriginFunc: func(origin string) bool {
            return origin == chromeExtensionOrigin
        },
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
        MaxAge:           12 * time.Hour,
    }
    router.Use(cors.New(corsConfig))
    
    // Routes
    router.POST("/analyze", analyzeHandler.Handle)
    
    return router
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** main.go —Å–æ–∫—Ä–∞—Ç–∏–ª—Å—è —Å 350 –¥–æ ~80 —Å—Ç—Ä–æ–∫

**Checkpoint:** `git commit -m "refactor: extract config loading and router setup from main()"`

---

#### ‚è∞ 15:00 - 16:00 | –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∑–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ (60 –º–∏–Ω)

**–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤:**
```bash
cd ai-back

# Unit —Ç–µ—Å—Ç—ã
go test ./... -v -cover

# –ü—Ä–æ–≤–µ—Ä–∫–∞ coverage
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# –û—Ç–∫—Ä—ã—Ç—å –æ—Ç—á—ë—Ç
xdg-open coverage.html  # Linux
open coverage.html      # macOS
```

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
PASS
coverage: 52.3% of statements
ok      langfuse-analyzer-backend/internal/handler        0.123s  coverage: 55.0%
ok      langfuse-analyzer-backend/internal/service        0.089s  coverage: 62.0%
ok      langfuse-analyzer-backend/internal/repository     0.145s  coverage: 71.0%
```

**–ü—Ä–æ–≤–µ—Ä–∫–∞ TypeScript:**
```bash
cd crome-ext

# –ö–æ–º–ø–∏–ª—è—Ü–∏—è
npm run build

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
npx tsc --noEmit

# –õ–∏–Ω—Ç–∏–Ω–≥
npm run lint
```

**Checkpoint:** `git commit -m "chore: verify all tests pass and coverage meets 50% target"`

---

#### ‚è∞ 16:00 - 17:00 | –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ README –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ (60 –º–∏–Ω)

**–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ `ai-back/README.md`:**

–î–æ–±–∞–≤–∏—Ç—å —Å–µ–∫—Ü–∏—é "Architecture":
```markdown
## üèóÔ∏è Architecture

This project follows Clean Architecture principles with clear separation of concerns:

### Layers

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           HTTP Handler Layer            ‚îÇ
‚îÇ  (Gin routes, request/response)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Service Layer                   ‚îÇ
‚îÇ  (Business logic, orchestration)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Repository Layer                  ‚îÇ
‚îÇ  (External API calls: Langfuse, AI)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Directory Structure

```
ai-back/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ server/
‚îÇ       ‚îî‚îÄ‚îÄ main.go              # Application entry point
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ handler/                 # HTTP handlers (Gin)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analyze_handler.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handler_test/
‚îÇ   ‚îú‚îÄ‚îÄ service/                 # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analyze_service.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ service_test/
‚îÇ   ‚îú‚îÄ‚îÄ repository/              # External API clients
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ langfuse_repository.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repository_test/
‚îÇ   ‚îú‚îÄ‚îÄ domain/                  # Domain models
‚îÇ   ‚îî‚îÄ‚îÄ config/                  # Configuration
‚îÇ       ‚îî‚îÄ‚îÄ config.go
‚îî‚îÄ‚îÄ pkg/
    ‚îî‚îÄ‚îÄ ai/                      # AI provider clients
        ‚îú‚îÄ‚îÄ client.go
        ‚îú‚îÄ‚îÄ openrouter.go
        ‚îî‚îÄ‚îÄ ollama.go
```

### Testing

All layers are fully testable with dependency injection:

```bash
# Run all tests
go test ./... -v

# With coverage
go test ./... -cover

# Generate coverage report
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

Current coverage: **52%** (target: 50%+)
```

**–°–æ–∑–¥–∞—Ç—å `ai-back/ARCHITECTURE.md`:**
```markdown
# Architecture Documentation

## Overview

This backend follows Clean Architecture principles to ensure:
- **Testability**: All dependencies are injected via interfaces
- **Maintainability**: Clear separation of concerns
- **Flexibility**: Easy to swap implementations (e.g., AI providers)

## Dependency Flow

```
main.go
  ‚Üì creates
Config ‚Üí AIClient, LangfuseRepository
  ‚Üì injects into
AnalyzeService
  ‚Üì injects into
AnalyzeHandler
  ‚Üì registered in
Gin Router
```

## Layer Responsibilities

### Handler Layer (`internal/handler/`)
- Parse HTTP requests
- Validate input
- Call service layer
- Format HTTP responses
- Handle HTTP-specific errors (400, 500, etc.)

**No business logic here!**

### Service Layer (`internal/service/`)
- Orchestrate business logic
- Coordinate between repositories
- Handle business errors
- Transform data if needed

**No HTTP knowledge here!**

### Repository Layer (`internal/repository/`)
- Communicate with external APIs
- Handle retries and timeouts
- Parse external responses
- Convert to domain models

**No business logic here!**

## Testing Strategy

### Unit Tests
- Mock all dependencies using interfaces
- Test each layer in isolation
- Use `testify/mock` for mocking

### Integration Tests
- Test multiple layers together
- Use `httptest` for HTTP testing
- Mock only external APIs

## Adding New Features

1. Define interface in service/repository
2. Implement in respective layer
3. Write tests with mocks
4. Inject via constructor
5. Wire up in main.go
```

**Checkpoint:** `git commit -m "docs: update README with architecture section and add ARCHITECTURE.md"`

---

#### ‚è∞ 17:00 - 18:00 | –§–∏–Ω–∞–ª—å–Ω—ã–π review –∏ merge (60 –º–∏–Ω)

**–ß–µ–∫–ª–∏—Å—Ç –ø–µ—Ä–µ–¥ merge:**

```bash
# 1. –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
go test ./... -v
‚úÖ PASS

# 2. Coverage >= 50%
go test ./... -cover
‚úÖ 52.3%

# 3. –ù–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –±–∞–≥–æ–≤
grep -r "defer.*Close()" ai-back/
‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ

# 4. Godoc –¥–ª—è –≤—Å–µ—Ö —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
go doc internal/handler
go doc internal/service
go doc internal/repository
‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ

# 5. TypeScript –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫
cd crome-ext && npm run build
‚úÖ OK

# 6. –ù–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è 'any'
grep -r ": any" crome-ext/src/
‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ

# 7. JSDoc –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ

# 8. README –æ–±–Ω–æ–≤–ª—ë–Ω
‚úÖ –û–±–Ω–æ–≤–ª—ë–Ω
```

**–°–æ–∑–¥–∞—Ç—å summary –∫–æ–º–º–∏—Ç:**
```bash
git log --oneline feat/2-day-optimization

# –†–µ–∑—É–ª—å—Ç–∞—Ç:
# abc1234 docs: update README with architecture section
# def5678 chore: verify all tests pass
# ghi9012 refactor: extract config loading
# jkl3456 docs: add JSDoc comments
# mno7890 fix: replace 'any' with proper types
# pqr1234 test: add integration test
# stu5678 test: add unit tests for handler
# vwx9012 docs: add Godoc comments
# yz01234 test: add unit tests for service
# abc5678 test: add unit tests for repository
# def9012 fix: add context to error messages
# ghi3456 refactor: introduce handler/service/repository layers
# jkl7890 fix: handle http.NewRequest error
# mno1234 fix: resource leak in retry loop
# pqr5678 chore: setup project structure
```

**Merge –≤ main:**
```bash
git checkout main
git merge feat/2-day-optimization --no-ff -m "feat: 2-day optimization - clean architecture + tests + bug fixes

Summary of changes:
- ‚úÖ Fixed 4 critical bugs (resource leak, error handling)
- ‚úÖ Implemented Clean Architecture (handler/service/repository)
- ‚úÖ Added unit tests (52% coverage)
- ‚úÖ Added Godoc/JSDoc documentation
- ‚úÖ Refactored main.go (350 ‚Üí 80 lines)
- ‚úÖ Fixed TypeScript 'any' usage
- ‚úÖ Updated README with architecture docs

Metrics:
- Test coverage: 0% ‚Üí 52%
- Critical bugs: 4 ‚Üí 0
- Architecture: Monolith ‚Üí Layered
- Documentation: 30% ‚Üí 70%
"

git push origin main
```

**–°–æ–∑–¥–∞—Ç—å Git tag:**
```bash
git tag -a v0.1.0 -m "Release v0.1.0: Clean Architecture + Tests

Changes:
- Clean Architecture implementation
- 52% test coverage
- All critical bugs fixed
- Comprehensive documentation
"

git push origin v0.1.0
```

**Checkpoint:** `git push origin main && git push origin v0.1.0`

---

### üìä –ò—Ç–æ–≥–∏ –î–Ω—è 2

**–í—ã–ø–æ–ª–Ω–µ–Ω–æ:**
- ‚úÖ Unit —Ç–µ—Å—Ç—ã –¥–ª—è handler (~55% coverage)
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ç–µ—Å—Ç
- ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω TypeScript `any`
- ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ JSDoc –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- ‚úÖ –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ main.go (350 ‚Üí 80 —Å—Ç—Ä–æ–∫)
- ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
- ‚úÖ Merge –≤ main

**–ú–µ—Ç—Ä–∏–∫–∏:**
- –¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ: 40% ‚Üí 52%
- main.go: 350 —Å—Ç—Ä–æ–∫ ‚Üí 80 —Å—Ç—Ä–æ–∫
- –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: 30% ‚Üí 70%

**Git –∫–æ–º–º–∏—Ç—ã:** 8 –∫–æ–º–º–∏—Ç–æ–≤ + 1 merge + 1 tag

---

## üìà –§–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏

| –ú–µ—Ç—Ä–∏–∫–∞ | –î–æ | –ü–æ—Å–ª–µ | –¶–µ–ª—å | –°—Ç–∞—Ç—É—Å |
|---------|-----|-------|------|--------|
| **–¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ** | 0% | 52% | 50% | ‚úÖ –ü—Ä–µ–≤—ã—à–µ–Ω–æ |
| **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏** | 4 | 0 | 0 | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ |
| **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞** | –ú–æ–Ω–æ–ª–∏—Ç | –°–ª–æ–∏ | –°–ª–æ–∏ | ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ |
| **Godoc –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏** | 0% | 70% | 60% | ‚úÖ –ü—Ä–µ–≤—ã—à–µ–Ω–æ |
| **JSDoc –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏** | 0% | 60% | 50% | ‚úÖ –ü—Ä–µ–≤—ã—à–µ–Ω–æ |
| **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `any`** | 1 | 0 | 0 | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ |
| **–£—Ç–µ—á–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤** | 1 | 0 | 0 | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ |
| **–°—Ç—Ä–æ–∫ –≤ main.go** | 350 | 80 | <150 | ‚úÖ –ü—Ä–µ–≤—ã—à–µ–Ω–æ |

---

## üí∞ –ë—é–¥–∂–µ—Ç —Ç–æ–∫–µ–Ω–æ–≤ ($20)

### –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∑–∞–¥–∞—á–∞–º:

| –ó–∞–¥–∞—á–∞ | –¢–æ–∫–µ–Ω—ã (–æ—Ü–µ–Ω–∫–∞) | –°—Ç–æ–∏–º–æ—Å—Ç—å |
|--------|-----------------|-----------|
| –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ | ~50K | $1.50 |
| –ù–∞–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ (repository) | ~80K | $2.40 |
| –ù–∞–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ (service) | ~80K | $2.40 |
| –ù–∞–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ (handler) | ~70K | $2.10 |
| –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã | ~100K | $3.00 |
| –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–≥–æ–≤ | ~40K | $1.20 |
| –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è (Godoc/JSDoc) | ~60K | $1.80 |
| TypeScript —Ç–∏–ø–∏–∑–∞—Ü–∏—è | ~30K | $0.90 |
| Review –∏ —Ñ–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è | ~40K | $1.20 |
| **–ò–¢–û–ì–û** | **~550K** | **$16.50** |

**–û—Å—Ç–∞—Ç–æ–∫:** $3.50 (—Ä–µ–∑–µ—Ä–≤ –Ω–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏)

---

## üéØ –î–æ—Å—Ç–∏–≥–Ω—É—Ç—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

### ‚úÖ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –±–∞–≥–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã:
1. ‚úÖ –£—Ç–µ—á–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –≤ `getTraceFromLangfuse()` ‚Äî –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
2. ‚úÖ –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ `http.NewRequest()` ‚Äî –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
3. ‚úÖ –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è `aiClient` ‚Äî –∑–∞–º–µ–Ω–µ–Ω–∞ –Ω–∞ DI
4. ‚úÖ –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤ –æ—à–∏–±–∫–∞—Ö ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω–æ

### ‚úÖ –¢–µ—Å—Ç—ã (52% coverage):
- Repository: 71% coverage
- Service: 62% coverage
- Handler: 55% coverage
- Integration: 1 end-to-end —Ç–µ—Å—Ç

### ‚úÖ Clean Architecture:
- Handler layer: –æ—Ç–¥–µ–ª—ë–Ω –æ—Ç main.go
- Service layer: –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞
- Repository layer: –≤–Ω–µ—à–Ω–∏–µ API
- Config: —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

### ‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:
- Godoc: 70% —Ñ—É–Ω–∫—Ü–∏–π
- JSDoc: 60% —Ñ—É–Ω–∫—Ü–∏–π
- README: –æ–±–Ω–æ–≤–ª—ë–Ω —Å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π
- ARCHITECTURE.md: —Å–æ–∑–¥–∞–Ω

---

## üöÄ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏ (–ø–æ—Å–ª–µ 2 –¥–Ω–µ–π)

### –§–∞–∑–∞ 3 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, 1-2 –Ω–µ–¥–µ–ª–∏):
1. –î–æ–≤–µ—Å—Ç–∏ coverage –¥–æ 70%+
2. –î–æ–±–∞–≤–∏—Ç—å E2E —Ç–µ—Å—Ç—ã –¥–ª—è Chrome Extension
3. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å CI/CD (GitHub Actions)
4. –î–æ–±–∞–≤–∏—Ç—å graceful shutdown
5. –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (zap/zerolog)
6. Prometheus –º–µ—Ç—Ä–∏–∫–∏

---

## üìù Git –∫–æ–º–º–∏—Ç—ã (–≤—Å–µ–≥–æ 15)

### –î–µ–Ω—å 1 (6 –∫–æ–º–º–∏—Ç–æ–≤):
1. `chore: setup project structure for clean architecture`
2. `fix: resource leak in getTraceFromLangfuse retry loop`
3. `fix: handle http.NewRequest error in getTraceFromLangfuse`
4. `refactor: introduce handler/service/repository layers`
5. `fix: add context to error messages for better debugging`
6. `test: add unit tests for LangfuseRepository (70% coverage)`
7. `test: add unit tests for AnalyzeService with mocks (60% coverage)`
8. `docs: add Godoc comments for all exported functions`

### –î–µ–Ω—å 2 (8 –∫–æ–º–º–∏—Ç–æ–≤ + merge + tag):
9. `test: add unit tests for AnalyzeHandler (50% coverage achieved)`
10. `test: add integration test for analyze flow`
11. `fix: replace 'any' with proper TypeScript interfaces`
12. `docs: add JSDoc comments for all TypeScript functions`
13. `refactor: extract config loading and router setup from main()`
14. `chore: verify all tests pass and coverage meets 50% target`
15. `docs: update README with architecture section and add ARCHITECTURE.md`
16. `feat: 2-day optimization - clean architecture + tests + bug fixes` (merge)
17. `v0.1.0` (tag)

---

## ‚ú® –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ó–∞ 2 –¥–Ω—è —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–µ–∫—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω –∏–∑ –º–æ–Ω–æ–ª–∏—Ç–∞ —Å 0% —Ç–µ—Å—Ç–æ–≤ –∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–º–∏ –±–∞–≥–∞–º–∏ –≤ —Ö–æ—Ä–æ—à–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å Clean Architecture, 52% test coverage –∏ –ø–æ–ª–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π.

**–ì–æ—Ç–æ–≤–æ –∫ production:** ‚ö†Ô∏è –ü–æ—á—Ç–∏ (–Ω—É–∂–Ω–∞ –§–∞–∑–∞ 3 –¥–ª—è –ø–æ–ª–Ω–æ–π –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏)  
**–ì–æ—Ç–æ–≤–æ –∫ –¥–∞–ª—å–Ω–µ–π—à–µ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ:** ‚úÖ –î–∞  
**–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–ª–≥:** üü¢ –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —Å–Ω–∏–∂–µ–Ω

---

*–ü–ª–∞–Ω —Å–æ–∑–¥–∞–Ω: 2026-01-24*  
*–ë—é–¥–∂–µ—Ç: $20 (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ ~$16.50)*  
*–í—Ä–µ–º—è: 2 –¥–Ω—è (16 —á–∞—Å–æ–≤)*
